import numpy as np
from sklearn.cluster import DBSCAN
import time

# ======= Конфигурация =======
OBSTACLE_RADIUS = 2.0
DETECTION_Z_THRESHOLD = 0.2
SAFE_DISTANCE = 5.0
DECEL_DIST = 4.0
BASE_SPEED = 2.5
MIN_SPEED = 0.5

# ======= Вспомогательные функции =======

def calculate_heading(start, end):
    dx = end.x_val - start.x_val
    dy = end.y_val - start.y_val
    return np.degrees(np.arctan2(dy, dx))


def smooth_rotate_to_yaw(client, current_yaw, target_yaw, rate=60):  # град/с
    """
    Плавный непрерывный поворот с заданной скоростью (не ступенчатый).
    """
    delta = (target_yaw - current_yaw + 360) % 360
    if delta > 180:
        delta -= 360  # кратчайшее направление

    # Ожидаем, что угол изменится на заданную скорость (rate)
    steps = int(abs(delta) / rate)
    for i in range(steps):
        # Разбиваем на шаги и выполняем повороты
        yaw_step = current_yaw + np.sign(delta) * rate * (i + 1)
        # Используем rotateToYawAsync (или аналогичный метод)
        client.rotateToYawAsync(yaw_step)  # Поворот на следующий шаг
        time.sleep(0.1)

    client.rotateToYawAsync(target_yaw)  # финальный поворот


def smooth_move_to_point(client, current_pos, target_point, max_speed=BASE_SPEED, decel_dist=DECEL_DIST):
    """
    Плавное движение с расчетом скорости по расстоянию и плавным поворотом.
    """
    dx = target_point.x_val - current_pos.x_val
    dy = target_point.y_val - current_pos.y_val
    dz = target_point.z_val - current_pos.z_val
    dist = np.sqrt(dx**2 + dy**2 + dz**2)
    speed = max(MIN_SPEED, min(max_speed, dist / decel_dist))

    orientation = client.getMultirotorState().kinematics_estimated.orientation
    yaw_now = orientation.to_euler_angles().z_val * 180 / np.pi
    heading = calculate_heading(current_pos, target_point)
    smooth_rotate_to_yaw(client, yaw_now, heading)

    client.moveToPositionAsync(target_point.x_val, target_point.y_val, target_point.z_val, speed).join()


def is_obstacle_near(current_pos, obstacle_centers, danger_radius=OBSTACLE_RADIUS):
    for center in obstacle_centers:
        dist = np.linalg.norm([
            center[0] - current_pos.x_val,
            center[1] - current_pos.y_val,
            center[2] - current_pos.z_val
        ])
        if dist < danger_radius:
            return True, dist
    return False, float('inf')


def find_safe_direction(current_pos, obstacle_centers, step=SAFE_DISTANCE, attempts=16):
    angles = np.linspace(0, 2 * np.pi, attempts, endpoint=False)
    for angle in angles:
        dx = step * np.cos(angle)
        dy = step * np.sin(angle)
        candidate = airgen.Vector3r(current_pos.x_val + dx, current_pos.y_val + dy, current_pos.z_val)
        danger, _ = is_obstacle_near(candidate, obstacle_centers)
        if not danger:
            return candidate
    return None


# ======= Старт =======
print("Дрон начинает тестовый облет.")

for i, target_point in enumerate(trajectory):
    while True:
        current_pos = client.getMultirotorState().kinematics_estimated.position
        lidar_data = client.getLidarData()
        points = np.array(lidar_data.point_cloud, dtype=np.float32).reshape(-1, 3)
        rr.log('lidar/points', rr.Points3D(points))

        above_ground = points[points[:, 2] > DETECTION_Z_THRESHOLD]

        if above_ground.shape[0] == 0:
            print("⚠️ Нет точек выше уровня земли — пропускаю кластеризацию")
            obstacle_centers = np.empty((0, 3))
        else:
            clustering = DBSCAN(eps=1.0, min_samples=10).fit(above_ground[:, :2])
            labels = clustering.labels_
            obstacle_centers = []

            for label in set(labels):
                if label == -1:
                    continue
                cluster_points = above_ground[labels == label]
                center = cluster_points.mean(axis=0)
                obstacle_centers.append(center)

            obstacle_centers = np.array(obstacle_centers)

        rr.log("lidar/obstacles", rr.Points3D(obstacle_centers))

        danger, dist = is_obstacle_near(current_pos, obstacle_centers)
        if danger:
            print(f"⚠️ Обнаружено препятствие на расстоянии {dist:.1f} м. Ищу обходной путь...")
            safe_point = find_safe_direction(current_pos, obstacle_centers)
            if safe_point:
                print("Перестроен маршрут. Лечу к безопасной точке...")
                smooth_move_to_point(client, current_pos, safe_point)
                print("Достиг безопасной точки. Возобновляю маршрут.")
                continue
        break

    current_pos = client.getMultirotorState().kinematics_estimated.position
    smooth_move_to_point(client, current_pos, target_point)

# ======= Завершающая посадка =======
print("Добрался до конечной точки. Осуществляю посадку...")

final_pos = client.getMultirotorState().kinematics_estimated.position
points_raw = client.getLidarData().point_cloud

if len(points_raw) > 0:
    points = np.array(points_raw, dtype=np.float32).reshape(-1, 3)
    ground_points = points[points[:, 2] < 0.5]
    if len(ground_points) > 0:
        min_z = float(np.min(ground_points[:, 2]) - 0.1)
    else:
        min_z = -3.0
else:
    min_z = -3.0

landing_point = airgen.Vector3r(final_pos.x_val, final_pos.y_val, min_z)
smooth_move_to_point(client, final_pos, landing_point, max_speed=0.8)

print("Дрон успешно посадил! Симуляция тестового полета завершена.")
client.landAsync().join()
